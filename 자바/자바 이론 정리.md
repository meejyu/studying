# 자바 이론 정리

1. 메소드

1-1. 메소드의 정의

![image-20210403230822607](C:\Users\진주\AppData\Roaming\Typora\typora-user-images\image-20210403230822607.png)

1-2. 지역변수

해당 지역내에서만 사용 가능

큰지역에서 쓴 변수는 작은 지역에서 사용가능한다.

작은지역에서 사용한 변수는 큰지역으로 가면 소멸된다.

1-3. 메소드 오버로딩(Overloading)

- 둘 이상의 메소드를 둘 이상 동시에 정의한 것
- 인자가 다르면 오버로딩이 성립된다.



2. 배열

2-1. 배열이란

같은 타입의 둘 이상의 데이터를 저장할수 있는 메모리 공간

자료형[] 배열명 = new 자료형[크기]

예시 : int[] numArr = new int[9]

2-2. for-each문(Enhanced for/ 향상된 for문)

- 배열의 일부가 아닌 전체를 참조할때 주로 사용되는 for문이다.
- 코드가 짧고 간결하여 빈번히 사용된다.
- 값의 변경은 허용하지 않는다.

형식 for(자료형 변수 : 배열(참조변수)) {

​				실행문장

​		}



3. 클래스

3-1. 클래스

클래스 :

- 대문자로 시작, 여러개의 클래스 선언가능
- 자바파일명과 public 클래스명은 동일해야함
- public 클래스 선언은 단 하나만 가능

클래스 형식

접근지정자 class 클래스명 {

​	멤버변수;

​	생성자메소드;

​	멤버메소드;

}

인스턴스(instance) : 클래스를 바탕으로 메모리에 생성된 실체

객체(object) : 클래스에 선언된 모양 그대로의 생성된 실체

참조값 : 생성된 인스턴스의 메모리 주소값

참조변수 : 메모리에 생성된 인스턴스를 가리키는 변수

3-2. 객체(인스턴스) 생성

![image-20210404005144920](C:\Users\진주\AppData\Roaming\Typora\typora-user-images\image-20210404005144920.png)

3-3. 생성된 객체의 접근방법

멤버변수의 접근

Person person = new Person();

person.name = “정우성”;

멤버메소드의 접근

Person person = new <u>Person();</u><- 생성자 호출

person.getName();

person.showInfo();

3-4. 생성자

객체 생성시 new 키워드를 통해 호출했던 메소드를 '생성자'라 한다.

3-5. 디폴트 생성자

class Account {	

String name;	

public Account(){} ← 디폴트 생성자

}

클래스는 반드시 하나 이상의 생성자, 매개변수와 실행부가 없으며, 

안만들어도 자동으로 만들어짐.

3-6. 생성자의 기본문법 및 규칙

생성자는 클래스명과 동일

주로 멤버변수 초기화에 사용멤버상수를 초기화 할 수 있다.

리턴값이 없다. 즉 값을 반환할 수 없다.

객체 생성시 딱 한번만 호출되고, 개발자가 임의로 호출할 수 없다.

메소드와 동일한 속성메소드 오버로딩이 가능하다.

3-7. 생성자 오버로딩

생성자는 매개변수의 갯수, 타입을 다르게 기술하여 여러개를 정의할 수 있다.



4. 접근제어지시자

![image-20210409090054332](C:\Users\진주\AppData\Roaming\Typora\typora-user-images\image-20210409090054332.png)



5. 정적변수 및 정적메소드

5-1. static변수

클래스 외부에서는 객체생성없이 클래스명으로 접근 가능

JVM은 실행과정에서 static변수가 초기화된다.

미리 메모리에 올려두기 때문에 실행하기 전에 메모리 공간을 차지함.



6. 상속1

6-1. 상속의 기본문법

class Man {

​	public man(String name) {

​		this.name = name;

​	} 

} - 부모클래스, 상위클래스

class BusinessMan extends man {} - 자식클래스, 하위클래스

super(name); 

형식] 

extend 부모클래스 : 을 통해 상속받음

super(인자) : 부모 생성자를 호출

6-2. 상속관계에 있는 클래스의 객체 생성2

하위 클래스의 생성자는 상위 클래스의 생성자 호출을 통해서 

상위 클래스의 인스턴스 변수를 초기화한다.

7. 상속2

7-1. 메소드 오버라이딩

- 부모클래스의 정의된 메소드를 완전히 동일하게 자식클래스에서 재정의 하는것

- 부모클래스의 메소드는 자식클래스의 메소드에 의해 가려져서 항상 자식클래스의 메소드가 호출된다.

- 부모클래스의 참조변수로 자식클래스의 객체를 참조할 수 있다,

7-2. 상위클래스의 참조변수로 하위클래스의 객체 참조

- 부모클래스의 참조변수로 자식 클래스이 객체를 참조할수 있다.
- 부모로 자식을 참조할때는 접근범위가 부모객체로 제한된다.

ex) A ref1 = new C();	B ref2 = new C();	C ref3 = new C();

7-3. instanceof 연산자

- 형변환이 가능한지 확인하는 연산자이다.
- 형변환이 가능할때 true를 반환한다.
- 클래스간에 상속관계가 있을떄 형변환이 가능하다.

8. 추상클래스

8-1. abstract클래스

- 객체생성을 허용하지 않는다

- 오버라이딩을 목적으로 선언된다. 

- 추상메소드를 포함하는 클래스는 반드시 추상클래스로 선언해야한다. 

  ex) <u>abstract</u> class Friedn{

  ​	public void showAllData() {

  ​	}

  ​	<u>public abstarct void showBasicInfo();</u>

  }

- 객체 생성이 안되는것 빼고는 클래스와 기능이 같음

- abstract를 상속하면 하위클래스도 객체 생성이 불가능하다

  단, 객체생성을 해야한다면 abstract 메소드를 오버라이딩하여 부모클래스의 메소드를 가리면 된다. 오버라이딩을 할 경우 abstract를 안붙여줘도 됨.

8-2. 인터페이스

- 인터페이스에 선언된 변수는 무조건 public static final으로 알아서 변환됨.
- 인터페이스에 선언된 메소드는 무조건 public abstract
- 클래스가 인터페이스를 상속할때는 extends 대신 implements 를 사용한다. 
- 인터페이스가 인터페이스를 상속할때는 extends를 사용한다.



내일할것들

Wrapper 클래스(개념만)

Math 클래스

Object 클래스

equals() 메소드

Random 클래스













